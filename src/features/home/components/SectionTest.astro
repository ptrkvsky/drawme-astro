<script>
  import {
    Curtains,
    Plane,
    RenderTarget,
    ShaderPass,
  } from 'https://cdn.jsdelivr.net/npm/curtainsjs@8.1.2/src/index.mjs';
  import { TextTexture } from 'https://gistcdn.githack.com/martinlaxenaire/549b3b01ff4bd9d29ce957edd8b56f16/raw/2f111abf99c8dc63499e894af080c198755d1b7a/TextTexture.js';

  const scrollFs = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec3 vVertexPosition;
    varying vec2 vTextureCoord;

    uniform sampler2D uRenderTexture;

    // lerped scroll deltas
    // negative when scrolling down, positive when scrolling up
    uniform float uScrollEffect;

    // default to 2.5
    uniform float uScrollStrength;


    void main() {
        vec2 scrollTextCoords = vTextureCoord;
        float horizontalStretch;

        // branching on an uniform is ok
        if(uScrollEffect >= 0.0) {
            scrollTextCoords.y *= 1.0 + -uScrollEffect * 0.00625 * uScrollStrength;
            horizontalStretch = sin(scrollTextCoords.y);
        }
        else if(uScrollEffect < 0.0) {
            scrollTextCoords.y += (scrollTextCoords.y - 1.0) * uScrollEffect * 0.00625 * uScrollStrength;
            horizontalStretch = sin(-1.0 * (1.0 - scrollTextCoords.y));
        }

        scrollTextCoords.x = scrollTextCoords.x * 2.0 - 1.0;
        scrollTextCoords.x *= 1.0 + uScrollEffect * 0.0035 * horizontalStretch * uScrollStrength;
        scrollTextCoords.x = (scrollTextCoords.x + 1.0) * 0.5;

        gl_FragColor = texture2D(uRenderTexture, scrollTextCoords);
    }
`;

  const vs = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    // default mandatory variables
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    // custom variables
    varying vec3 vVertexPosition;
    varying vec2 vTextureCoord;

    void main() {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        // varyings
        vVertexPosition = aVertexPosition;
        vTextureCoord = aTextureCoord;
    }
`;

  const fs = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec3 vVertexPosition;
    varying vec2 vTextureCoord;

    uniform sampler2D uTexture;

    void main( void ) {
        gl_FragColor = texture2D(uTexture, vTextureCoord);
    }
`;

  window.addEventListener('load', () => {
    // create curtains instance
    const curtains = new Curtains({
      container: 'canvas',
      pixelRatio: Math.min(1.5, window.devicePixelRatio),
    });

    // track scroll values
    const scroll = {
      value: 0,
      lastValue: 0,
      effect: 0,
    };

    // on success
    curtains.onSuccess(() => {
      const fonts = {
        list: [
          'normal 400 1em "Archivo Black", sans-serif',
          'normal 300 1em "Merriweather Sans", sans-serif',
        ],
        loaded: 0,
      };

      // load the fonts first
      fonts.list.forEach((font) => {
        document.fonts.load(font).then(() => {
          fonts.loaded++;

          if (fonts.loaded === fonts.list.length) {
            // create our shader pass
            const scrollPass = new ShaderPass(curtains, {
              fragmentShader: scrollFs,
              depth: false,
              uniforms: {
                scrollEffect: {
                  name: 'uScrollEffect',
                  type: '1f',
                  value: scroll.effect,
                },
                scrollStrength: {
                  name: 'uScrollStrength',
                  type: '1f',
                  value: 2.5,
                },
              },
            });

            // calculate the lerped scroll effect
            scrollPass.onRender(() => {
              scroll.lastValue = scroll.value;
              scroll.value = curtains.getScrollValues().y;

              // clamp delta
              scroll.delta = Math.max(
                -30,
                Math.min(30, scroll.lastValue - scroll.value)
              );

              scroll.effect = curtains.lerp(scroll.effect, scroll.delta, 0.05);
              scrollPass.uniforms.scrollEffect.value = scroll.effect;
            });

            // create our text planes
            const textEls = document.querySelectorAll('.text-plane');
            textEls.forEach((textEl) => {
              const textPlane = new Plane(curtains, textEl, {
                vertexShader: vs,
                fragmentShader: fs,
              });

              // create the text texture and... that's it!
              const textTexture = new TextTexture({
                plane: textPlane,
                textElement: textPlane.htmlElement,
                sampler: 'uTexture',
                resolution: 1.5,
                skipFontLoading: true, // we've already loaded the fonts
              });
            });
          }
        });
      });
    });
  });
</script>

<div id="canvas"></div>
<div id="content">
  <h1>
    <span class="text-plane">Martin Laxenaire</span>
  </h1>

  <h2>
    <span class="text-plane">
      Rendering text<br />
      to WebGL
    </span>
  </h2>

  <div id="process" class="text-block">
    <p>
      <span class="text-plane">
        This is an example of how we can render whole blocks of text to WebGL
        thanks to curtains.js and the TextTexture class.
      </span>
    </p>
    <p>
      <span class="text-plane">
        A WebGL plane is created for all elements that have a "text-plane" class
        and their text contents are drawn inside a 2D canvas, which is then used
        as a WebGL texture.
      </span>
    </p>
  </div>

  <div id="scroll" class="text-block">
    <p>
      <span class="text-plane">
        We're using an additional shader pass to add a cool effect on scroll
        that makes you feel like the content is actually dragged.
      </span>
    </p>
    <p>
      <span class="text-plane"> Try to scroll down to see what happens!</span>
    </p>
  </div>

  <div id="lipsum" class="text-block">
    <p>
      <span class="text-plane">
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque a
        dolor posuere nisi tempus rhoncus. Curabitur venenatis velit a tellus
        porttitor, sed efficitur ipsum volutpat. Nunc ante ante, convallis in
        commodo eget, semper ac ex. Fusce lobortis risus vel nisl interdum
        imperdiet. Nulla facilisi
      </span>
    </p>
    <p>
      <span class="text-plane">
        Cras hendrerit iaculis est at vestibulum. Integer tincidunt mi id metus
        mollis, in fermentum odio sagittis. Vestibulum ante ipsum primis in
        faucibus orci luctus et ultrices posuere cubilia curae; Phasellus in
        efficitur diam.
      </span>
    </p>
  </div>
</div>

<style>
  #canvas {
    position: relative;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  .text-plane {
    display: inline-block;

    /* apply negative margins and padding to avoid chars from being cropped */
    margin: -1em;
    padding: 1em;

    /* hide the original text content */
    opacity: 0;
  }

  #content {
    width: 100%;
    padding: 2.5vw;
    box-sizing: border-box;
    position: relative;
    z-index: 2;
  }

  #content h1 {
    text-align: center;
    margin: 25vh 0;
    font-size: 6vw;
    text-transform: uppercase;
    font-family: 'Archivo Black', sans-serif;
    font-weight: 400;
    line-height: 1;
  }

  #content h2 {
    width: 50%;
    margin: 15vh 0 15vh 50%;
    font-size: 4vw;
    text-transform: uppercase;
    font-family: 'Archivo Black', sans-serif;
    font-weight: 400;
    line-height: 1;
  }

  .text-block {
    width: 50%;
    margin: 15vh 0;
  }

  #scroll {
    margin-left: 25%;
  }

  #lipsum {
    margin-left: 50%;
  }
</style>
